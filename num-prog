Program 1: Create a NumPy Array
Purpose
Create a NumPy array from a Python list.
Code
import numpy as np

arr = np.array([10, 20, 30, 40])
print(arr)
Explanation
np.array() converts a Python list into a NumPy array.
NumPy arrays are faster and more memory-efficient than lists.
Output will be: [10 20 30 40]

Program 2: Create an Array of Zeros and Ones
Purpose
Create arrays filled with zeros and ones.
Code
import numpy as np

zeros_array = np.zeros(5)
ones_array = np.ones(5)

print(zeros_array)
print(ones_array)
Explanation
np.zeros(5) creates 5 elements filled with 0
np.ones(5) creates 5 elements filled with 1
Commonly used in machine learning initialization

Program 3: Create an Array with a Range
Purpose
Generate numbers within a range.
Code
import numpy as np

arr = np.arange(1, 11)
print(arr)
Explanation
np.arange(start, stop) works like Python range()
Generates numbers from 1 to 10 (11 is excluded)

Program 4: Reshape an Array
Purpose
Change the shape of an array.
Code
import numpy as np

arr = np.arange(1, 7)
reshaped = arr.reshape(2, 3)

print(reshaped)
Explanation
Original array has 6 elements
Reshaped into 2 rows and 3 columns
Total elements must remain the same

Program 5: Find Array Size, Shape, and Data Type
Purpose
Get array properties.
Code
import numpy as np

arr = np.array([[1, 2], [3, 4]])

print("Shape:", arr.shape)
print("Size:", arr.size)
print("Data type:", arr.dtype)
Explanation
shape → rows and columns
size → total number of elements
dtype → type of data (int, float, etc.)

Program 6: Mathematical Operations on Arrays
Purpose
Perform element-wise operations.
Code
import numpy as np

a = np.array([10, 20, 30])
b = np.array([1, 2, 3])

print(a + b)
print(a - b)
print(a * b)
print(a / b)
Explanation
Operations happen element by element
NumPy removes the need for loops
Faster than Python lists

Program 7: Find Maximum, Minimum, and Mean
Purpose
Perform statistical operations.
Code
import numpy as np

arr = np.array([10, 20, 30, 40])

print("Max:", np.max(arr))
print("Min:", np.min(arr))
print("Mean:", np.mean(arr))
Explanation
np.max() → largest value
np.min() → smallest value
np.mean() → average value

Program 8: Indexing and Slicing
Purpose
Access specific elements.
Code
import numpy as np

arr = np.array([10, 20, 30, 40, 50])

print(arr[0])
print(arr[1:4])
Explanation
arr[0] → first element
arr[1:4] → elements from index 1 to 3
Similar to Python list slicing

Program 9: Boolean Filtering
Purpose
Filter elements using conditions.
Code
import numpy as np

arr = np.array([10, 25, 30, 15, 40])

result = arr[arr > 20]
print(result)
Explanation
Condition arr > 20 creates a boolean array
Only values greater than 20 are selected
Useful in data analysis

Program 10: Matrix Multiplication
Purpose
Multiply two matrices.
Code
import numpy as np

a = np.array([[1, 2], [3, 4]])
b = np.array([[5, 6], [7, 8]])

result = np.dot(a, b)
print(result)
Explanation
np.dot() performs matrix multiplication
Used in machine learning and linear algebra
Rows of a × columns of b


Advanced NumPy Programs with Explanations

Program 1: Broadcasting in NumPy
Goal
Add a 1D array to a 2D array without loops.
Code
import numpy as np

matrix = np.array([[1, 2, 3],
                   [4, 5, 6]])

vector = np.array([10, 20, 30])

result = matrix + vector
print(result)
Explanation
NumPy automatically expands vector to match each row
No loops needed → faster execution
Used heavily in ML feature scaling

Program 2: Vectorization vs Loop (Performance)
Goal
Show why NumPy is faster than Python loops.
Code
import numpy as np
import time

arr = np.arange(1_000_000)

start = time.time()
arr * 2
print("Vectorized time:", time.time() - start)
Explanation
NumPy executes operations in C internally
Avoids Python loops
Crucial for big data processing

Program 3: Fancy Indexing
Goal
Access multiple random elements at once.
Code
import numpy as np

arr = np.array([10, 20, 30, 40, 50])

indexes = [0, 2, 4]
print(arr[indexes])
Explanation
Multiple indexes at once
Faster than looping
Used in sampling data

Program 4: Boolean Masking on 2D Data
Goal
Filter rows using conditions.
Code
import numpy as np

data = np.array([[101, 85],
                 [102, 45],
                 [103, 78]])

passed = data[data[:, 1] > 60]
print(passed)
Explanation
data[:,1] selects marks column
Only rows with marks > 60 returned
Used in student filtering, ML datasets

Program 5: Replace Missing Values (NaN Handling)
Goal
Clean missing data.
Code
import numpy as np

arr = np.array([10, np.nan, 30, np.nan, 50])

cleaned = np.nan_to_num(arr, nan=0)
print(cleaned)
Explanation
np.nan represents missing values
nan_to_num() replaces NaN with 0
Data cleaning step before ML

Program 6: Stack and Split Arrays
Goal
Combine and split datasets.
Code
import numpy as np

a = np.array([1, 2, 3])
b = np.array([4, 5, 6])

stacked = np.vstack((a, b))
print(stacked)

split = np.hsplit(stacked, 3)
print(split)
Explanation
vstack() → vertical stacking
hsplit() → column-wise split
Used in feature engineering

Program 7: Linear Algebra – Solve Equations
Goal
Solve linear equations.
Code
import numpy as np

A = np.array([[2, 1],
              [1, 3]])

B = np.array([8, 13])

solution = np.linalg.solve(A, B)
print(solution)
Explanation
Solves equations like:
o2x + y = 8
ox + 3y = 13
Used in ML optimization problems

Program 8: Eigenvalues and Eigenvectors
Goal
Feature transformation (PCA concept).
Code
import numpy as np

matrix = np.array([[4, 2],
                   [1, 3]])

values, vectors = np.linalg.eig(matrix)
print(values)
print(vectors)
Explanation
Eigenvalues → importance
Eigenvectors → direction
Used in PCA, dimensionality reduction

Program 9: Random Sampling & Reproducibility
Goal
Generate repeatable random data.
Code
import numpy as np

np.random.seed(42)

data = np.random.randint(1, 100, 10)
print(data)
Explanation
Same output every time
Critical for ML experiments
Ensures reproducibility

Program 10: Normalization (Feature Scaling)
Goal
Scale data between 0 and 1.
Code
import numpy as np

data = np.array([50, 60, 70, 80, 90])

normalized = (data - np.min(data)) / (np.max(data) - np.min(data))
print(normalized)
Explanation
Prevents bias in ML models
Makes training faster and stable
Used in regression & neural networks
